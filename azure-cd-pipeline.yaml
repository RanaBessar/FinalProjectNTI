# ============================================================================
# Azure DevOps CD Pipeline - GitOps Deployment (ArgoCD Driven)
# ============================================================================
# This pipeline updates GitOps manifests then ArgoCD syncs automatically
# Author: DevOps Team
# Version: 3.0.4
# ============================================================================

trigger:
  branches:
    include:
      - main
  paths:
    include:
      - gitops/**
      - helm/nti-app/**
      - azure-cd-pipeline.yaml

pr:
  branches:
    include:
      - main
  paths:
    include:
      - gitops/**
      - helm/nti-app/**

pool:
  name: self-hosted-pool
  demands:
     - Agent.OS -equals Linux

variables:
  AWS_DEFAULT_REGION: "us-east-1"
  CLUSTER_NAME: "nti-final-nonprod-eks"

  APP_NAME: "nti-app"
  APP_NAMESPACE: "nti-app"
  ENVIRONMENT: "nonprod"
  DEPLOYMENT_NAME: "nti-app-nonprod"
  HELM_WORKING_DIR: "helm"
  GITOPS_DIR: "gitops"

  RUN_ARGOCD_SYNC: "true"
  RUN_SMOKE_TESTS: "true"

stages:

# ================================
# Validate Stage
# ================================
- stage: Validate
  displayName: "‚úÖ Validate Helm & GitOps"
  jobs:
    - job: ValidateConfig
      displayName: "Validate Helm Chart + GitOps YAML"
      timeoutInMinutes: 15

      steps:
        - checkout: self
          clean: true
          fetchDepth: 1

        - task: HelmInstaller@1
          displayName: "Install Helm"
          inputs:
            helmVersionToInstall: "latest"

        - script: |
            echo "====================================="
            echo " Pipeline Information"
            echo "====================================="
            echo "Build ID: $(Build.BuildId)"
            echo "Branch: $(Build.SourceBranchName)"
            echo "App Name: $(APP_NAME)"
            echo "Namespace: $(APP_NAMESPACE)"
          displayName: "Pipeline Information"

        - script: |
            set -e
            echo "====================================="
            echo " Helm Chart Validation"
            echo "====================================="

            helm lint ./$(HELM_WORKING_DIR)/$(APP_NAME)

            echo "‚úÖ Helm lint passed"
          displayName: "Validate Helm Chart"

        - script: |
            set -e
            echo "====================================="
            echo " Helm Template Dry Run"
            echo "====================================="

            helm template $(APP_NAME) ./$(HELM_WORKING_DIR)/$(APP_NAME) \
              --values ./$(HELM_WORKING_DIR)/$(APP_NAME)/values-nonprod.yaml \
              --namespace $(APP_NAMESPACE) \
              --debug > /dev/null

            echo "‚úÖ Helm template renders successfully"
          displayName: "Helm Template Dry Run"

# ================================
# GitOps Update Stage
# ================================
- stage: GitOps_Update
  displayName: "‚úçÔ∏è Update GitOps Manifests"
  dependsOn: Validate
  condition: succeeded()

  jobs:
    - job: UpdateGitOps
      displayName: "Update image tag in GitOps repo"
      timeoutInMinutes: 15

      steps:
        - checkout: self
          clean: true
          persistCredentials: true

        - script: |
            set -e
            echo "====================================="
            echo " Validate AWS Credentials"
            echo "====================================="

            mkdir -p ~/.aws

            cat > ~/.aws/credentials <<EOF
            [default]
            aws_access_key_id=$(AWS_ACCESS_KEY_ID)
            aws_secret_access_key=$(AWS_SECRET_ACCESS_KEY)
            EOF

            cat > ~/.aws/config <<EOF
            [default]
            region=$(AWS_DEFAULT_REGION)
            output=json
            EOF

            echo "AWS CLI Version:"
            aws --version

            aws sts get-caller-identity

            echo "‚úÖ AWS credentials valid"
          displayName: "Validate AWS Credentials"
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            set -e
            echo "====================================="
            echo " Install yq"
            echo "====================================="

            if ! command -v yq >/dev/null 2>&1; then
              echo "yq not found... installing..."
              mkdir -p $HOME/bin
              wget -qO $HOME/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
              chmod +x $HOME/bin/yq
              export PATH="$HOME/bin:$PATH"
              echo "##vso[task.prependpath]$HOME/bin"
            fi

            echo "yq version:"
            yq --version
          displayName: "Install yq"

        - script: |
            set -e
            echo "====================================="
            echo " Get Latest Image Tag from ECR"
            echo "====================================="

            AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
            ECR_REGISTRY="$AWS_ACCOUNT_ID.dkr.ecr.$(AWS_DEFAULT_REGION).amazonaws.com"

            LATEST_TAG=$(aws ecr describe-images \
              --repository-name $(APP_NAME) \
              --region $(AWS_DEFAULT_REGION) \
              --query 'sort_by(imageDetails,& imagePushedAt)[-1].imageTags[0]' \
              --output text)

            if [ -z "$LATEST_TAG" ] || [ "$LATEST_TAG" = "None" ]; then
              echo "‚ùå Could not fetch latest image tag from ECR"
              exit 1
            fi

            echo "Latest image tag: $LATEST_TAG"
            echo "##vso[task.setvariable variable=LATEST_TAG]$LATEST_TAG"
            echo "##vso[task.setvariable variable=ECR_REGISTRY]$ECR_REGISTRY"
          displayName: "Get Latest Tag from ECR"
          env:
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            set -e
            echo "====================================="
            echo " Update GitOps values-nonprod.yaml"
            echo "====================================="

            VALUES_FILE="$(GITOPS_DIR)/nonprod/$(APP_NAME)/values-nonprod.yaml"

            if [ ! -f "$VALUES_FILE" ]; then
              echo "‚ùå values file not found: $VALUES_FILE"
              exit 1
            fi

            echo "Updating image.repository and image.tag..."

            yq -i ".image.repository = \"$(ECR_REGISTRY)/$(APP_NAME)\"" $VALUES_FILE
            yq -i ".image.tag = \"$(LATEST_TAG)\"" $VALUES_FILE

            echo ""
            echo "Updated file content:"
            cat $VALUES_FILE
          displayName: "Update GitOps Values File"

        - script: |
            set -e
            echo "====================================="
            echo " Commit & Push GitOps Changes"
            echo "====================================="

            git config user.email "azure-devops@nti.com"
            git config user.name "Azure DevOps Pipeline"

            echo "Fetching all branches..."
            git fetch --all

            echo "Switching to main branch..."
            git checkout main 2>/dev/null || git checkout -B main origin/main

            echo "Pull latest changes from main..."
            git pull origin main --rebase || true

            git add gitops/nonprod/$(APP_NAME)/values-nonprod.yaml

            git commit -m "Update $(APP_NAME) image tag to $(LATEST_TAG)" || echo "No changes to commit"

            echo "Pushing changes to GitHub..."
            git push origin HEAD:main
          displayName: "Commit & Push GitOps"

# ================================
# ArgoCD Sync Stage
# ================================
- stage: ArgoCD_Sync
  displayName: "üîÑ ArgoCD Sync"
  dependsOn: GitOps_Update
  condition: and(succeeded(), eq(variables['RUN_ARGOCD_SYNC'], 'true'))

  jobs:
    - job: SyncArgo
      displayName: "Sync ArgoCD Application"
      timeoutInMinutes: 15

      steps:
        - checkout: self
          clean: true

        # FIXED: Install kubectl manually (NO SUDO)
        - script: |
            set -e
            echo "====================================="
            echo " Install kubectl manually (EKS 1.35 - No sudo)"
            echo "====================================="

            mkdir -p $HOME/bin

            curl -LO "https://dl.k8s.io/release/v1.35.0/bin/linux/amd64/kubectl"

            chmod +x kubectl
            mv kubectl $HOME/bin/kubectl

            echo "##vso[task.prependpath]$HOME/bin"

            kubectl version --client
          displayName: "Install kubectl (Manual - No sudo)"

        - script: |
            set -e
            echo "====================================="
            echo " Configure AWS Credentials"
            echo "====================================="

            mkdir -p ~/.aws

            cat > ~/.aws/credentials <<EOF
            [default]
            aws_access_key_id=$(AWS_ACCESS_KEY_ID)
            aws_secret_access_key=$(AWS_SECRET_ACCESS_KEY)
            EOF

            cat > ~/.aws/config <<EOF
            [default]
            region=$(AWS_DEFAULT_REGION)
            output=json
            EOF

            aws sts get-caller-identity
            echo "‚úÖ AWS credentials valid"
          displayName: "Configure AWS Credentials"
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            set -e
            echo "====================================="
            echo " Configure kubeconfig"
            echo "====================================="

            mkdir -p $HOME/.kube

            aws eks update-kubeconfig \
              --region "$(AWS_DEFAULT_REGION)" \
              --name "$(CLUSTER_NAME)" \
              --kubeconfig "$HOME/.kube/config"

            export KUBECONFIG="$HOME/.kube/config"

            echo "====================================="
            echo " Ensure ArgoCD Application Exists"
            echo "====================================="

            APP_MANIFEST="$(GITOPS_DIR)/nonprod/$(APP_NAME)/application.yaml"
            if [ -f "$APP_MANIFEST" ]; then
              echo "Applying ArgoCD Application manifest..."
              kubectl apply -f "$APP_MANIFEST"
            else
              echo "‚ö†Ô∏è  Application manifest not found: $APP_MANIFEST"
            fi

            echo "====================================="
            echo " Check ArgoCD App Status"
            echo "====================================="

            kubectl get applications -n argo || true

            echo "Waiting for ArgoCD to sync and create resources..."
            RETRIES=30
            for i in $(seq 1 $RETRIES); do
              if kubectl get namespace $(APP_NAMESPACE) >/dev/null 2>&1; then
                echo "‚úÖ Namespace $(APP_NAMESPACE) exists"
                break
              fi
              echo "Waiting for namespace... ($i/$RETRIES)"
              sleep 10
            done

            if kubectl get deployment/$(DEPLOYMENT_NAME) -n $(APP_NAMESPACE) >/dev/null 2>&1; then
              echo "Waiting for deployment rollout..."
              kubectl rollout status deployment/$(DEPLOYMENT_NAME) -n $(APP_NAMESPACE) --timeout=300s || true
            fi
          displayName: "Check ArgoCD Application"
          env:
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            set -e
            echo "====================================="
            echo " Print ArgoCD UI & Application Links"
            echo "====================================="

            echo ""
            echo "üîπ ArgoCD UI Link (if ingress exists):"

            ARGOCD_HOST=$(kubectl get ingress -n argo -o jsonpath="{.items[0].spec.rules[0].host}" 2>/dev/null || true)

            if [ -n "$ARGOCD_HOST" ]; then
              echo "‚úÖ ArgoCD UI: https://$ARGOCD_HOST"
              echo "‚úÖ ArgoCD Application: https://$ARGOCD_HOST/applications/$(APP_NAME)"
            else
              echo "‚ö†Ô∏è No ArgoCD ingress found."
              echo "‚û°Ô∏è Use port-forward to access UI:"
              echo "kubectl port-forward svc/argocd-server -n argo 9090:443"
              echo "Then open: https://localhost:9090"
              echo "Application URL: https://localhost:9090/applications/$(APP_NAME)"
            fi

            echo ""
            echo "üîπ Application Public URL (if ingress exists):"

            APP_HOST=$(kubectl get ingress -n $(APP_NAMESPACE) -o jsonpath="{.items[0].spec.rules[0].host}" 2>/dev/null || true)

            if [ -n "$APP_HOST" ]; then
              echo "‚úÖ Application URL: http://$APP_HOST"
            else
              echo "‚ö†Ô∏è No ingress found for application in namespace $(APP_NAMESPACE)"
            fi
          displayName: "Print ArgoCD & App URLs"

# ================================
# Smoke Test Stage
# ================================
- stage: Smoke_Tests
  displayName: "üß™ Smoke Tests"
  dependsOn: ArgoCD_Sync
  condition: and(succeeded(), eq(variables['RUN_SMOKE_TESTS'], 'true'))

  jobs:
    - job: RunSmokeTests
      displayName: "Run Smoke Tests"
      timeoutInMinutes: 15

      steps:
        - checkout: self
          clean: true

        # FIXED: Install kubectl manually (NO SUDO)
        - script: |
            set -e
            echo "====================================="
            echo " Install kubectl manually (EKS 1.35 - No sudo)"
            echo "====================================="

            mkdir -p $HOME/bin

            curl -LO "https://dl.k8s.io/release/v1.35.0/bin/linux/amd64/kubectl"

            chmod +x kubectl
            mv kubectl $HOME/bin/kubectl

            echo "##vso[task.prependpath]$HOME/bin"

            kubectl version --client
          displayName: "Install kubectl (Manual - No sudo)"

        - script: |
            set -e
            echo "====================================="
            echo " Configure AWS Credentials"
            echo "====================================="

            mkdir -p ~/.aws

            cat > ~/.aws/credentials <<EOF
            [default]
            aws_access_key_id=$(AWS_ACCESS_KEY_ID)
            aws_secret_access_key=$(AWS_SECRET_ACCESS_KEY)
            EOF

            cat > ~/.aws/config <<EOF
            [default]
            region=$(AWS_DEFAULT_REGION)
            output=json
            EOF

            aws sts get-caller-identity
            echo "‚úÖ AWS credentials valid"
          displayName: "Configure AWS Credentials"
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            set -e
            echo "====================================="
            echo " Configure kubeconfig"
            echo "====================================="

            mkdir -p $HOME/.kube

            aws eks update-kubeconfig \
              --region "$(AWS_DEFAULT_REGION)" \
              --name "$(CLUSTER_NAME)" \
              --kubeconfig "$HOME/.kube/config"

            export KUBECONFIG="$HOME/.kube/config"

            echo "====================================="
            echo " Smoke Tests for $(APP_NAME)"
            echo "====================================="

            echo "Checking namespace exists..."
            if ! kubectl get namespace $(APP_NAMESPACE) >/dev/null 2>&1; then
              echo "‚ö†Ô∏è  Namespace $(APP_NAMESPACE) not found - ArgoCD may not have synced yet"
              echo "Waiting for namespace creation..."
              RETRIES=18
              for i in $(seq 1 $RETRIES); do
                if kubectl get namespace $(APP_NAMESPACE) >/dev/null 2>&1; then
                  echo "‚úÖ Namespace created"
                  break
                fi
                if [ $i -eq $RETRIES ]; then
                  echo "‚ùå Namespace still not found after waiting"
                  exit 1
                fi
                sleep 10
              done
            fi

            echo "Waiting for deployment..."
            RETRIES=12
            for i in $(seq 1 $RETRIES); do
              if kubectl get deployment/$(DEPLOYMENT_NAME) -n $(APP_NAMESPACE) >/dev/null 2>&1; then
                break
              fi
              echo "Deployment not ready yet... ($i/$RETRIES)"
              sleep 10
            done

            kubectl rollout status deployment/$(DEPLOYMENT_NAME) -n $(APP_NAMESPACE) --timeout=300s

            kubectl get pods -n $(APP_NAMESPACE)
            kubectl get svc -n $(APP_NAMESPACE)
            kubectl get ingress -n $(APP_NAMESPACE) || true

            echo "‚úÖ Smoke tests passed"
          displayName: "Run Smoke Tests"
          env:
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            set -e
            echo "====================================="
            echo "üîó ArgoCD & Application URLs"
            echo "====================================="

            ARGOCD_HOST=$(kubectl get ingress -n argo -o jsonpath="{.items[0].spec.rules[0].host}" 2>/dev/null || true)
            if [ -n "$ARGOCD_HOST" ]; then
              ARGOCD_URL="https://$ARGOCD_HOST"
              ARGOCD_APP_URL="https://$ARGOCD_HOST/applications/$(APP_NAME)"
              echo "‚úÖ ArgoCD UI: $ARGOCD_URL"
              echo "‚úÖ ArgoCD Application: $ARGOCD_APP_URL"
            else
              ARGOCD_URL="https://localhost:9090"
              ARGOCD_APP_URL="https://localhost:9090/applications/$(APP_NAME)"
              echo "‚ö†Ô∏è No ArgoCD ingress found. Use port-forward:"
              echo "kubectl port-forward svc/argocd-server -n argo 9090:443"
              echo "Then open: $ARGOCD_URL"
              echo "Application URL: $ARGOCD_APP_URL"
            fi

            APP_HOST=$(kubectl get ingress -n $(APP_NAMESPACE) -o jsonpath="{.items[0].spec.rules[0].host}" 2>/dev/null || true)
            if [ -n "$APP_HOST" ]; then
              APP_URL="http://$APP_HOST"
              echo "‚úÖ Application URL: $APP_URL"
            else
              APP_URL=""
              echo "‚ö†Ô∏è No ingress found for application in namespace $(APP_NAMESPACE)"
            fi

            echo "##vso[task.setvariable variable=ARGOCD_URL;isOutput=true]$ARGOCD_URL"
            echo "##vso[task.setvariable variable=ARGOCD_APP_URL;isOutput=true]$ARGOCD_APP_URL"
            echo "##vso[task.setvariable variable=APP_URL;isOutput=true]$APP_URL"
          displayName: "Publish ArgoCD & App URLs"
          env:
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)
