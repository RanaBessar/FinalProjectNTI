# ============================================================================
# Azure DevOps CD Pipeline - GitOps Deployment (ArgoCD Driven)
# ============================================================================
# This pipeline updates GitOps manifests then ArgoCD syncs automatically
# Author: DevOps Team
# Version: 3.0.2
# ============================================================================

trigger:
  branches:
    include:
      - main
  paths:
    include:
      - gitops/**
      - helm/nti-app/**
      - azure-cd-pipeline.yaml

pr:
  branches:
    include:
      - main
  paths:
    include:
      - gitops/**
      - helm/nti-app/**

pool:
  name: SelfHostedPool
  demands:
    - agent.os -equals Linux

variables:
  AWS_DEFAULT_REGION: "us-east-1"
  CLUSTER_NAME: "nti-final-nonprod-eks"

  APP_NAME: "nti-app"
  APP_NAMESPACE: "nti-app"
  HELM_WORKING_DIR: "helm"
  GITOPS_DIR: "gitops"

  RUN_ARGOCD_SYNC: "true"
  RUN_SMOKE_TESTS: "true"

stages:

# ================================
# Validate Stage
# ================================
- stage: Validate
  displayName: "âœ… Validate Helm & GitOps"
  jobs:
    - job: ValidateConfig
      displayName: "Validate Helm Chart + GitOps YAML"
      timeoutInMinutes: 15

      steps:
        - checkout: self
          clean: true
          fetchDepth: 1

        - task: HelmInstaller@1
          displayName: "Install Helm"
          inputs:
            helmVersionToInstall: "latest"

        - script: |
            echo "====================================="
            echo " Pipeline Information"
            echo "====================================="
            echo "Build ID: $(Build.BuildId)"
            echo "Branch: $(Build.SourceBranchName)"
            echo "App Name: $(APP_NAME)"
            echo "Namespace: $(APP_NAMESPACE)"
          displayName: "Pipeline Information"

        - script: |
            set -e
            echo "====================================="
            echo " Helm Chart Validation"
            echo "====================================="

            helm lint ./$(HELM_WORKING_DIR)/$(APP_NAME)

            echo "âœ… Helm lint passed"
          displayName: "Validate Helm Chart"

        - script: |
            set -e
            echo "====================================="
            echo " Helm Template Dry Run"
            echo "====================================="

            helm template $(APP_NAME) ./$(HELM_WORKING_DIR)/$(APP_NAME) \
              --values ./$(HELM_WORKING_DIR)/$(APP_NAME)/values-nonprod.yaml \
              --namespace $(APP_NAMESPACE) \
              --debug > /dev/null

            echo "âœ… Helm template renders successfully"
          displayName: "Helm Template Dry Run"

# ================================
# GitOps Update Stage
# ================================
- stage: GitOps_Update
  displayName: "âœï¸ Update GitOps Manifests"
  dependsOn: Validate
  condition: succeeded()

  jobs:
    - job: UpdateGitOps
      displayName: "Update image tag in GitOps repo"
      timeoutInMinutes: 15

      steps:
        - checkout: self
          clean: true
          persistCredentials: true

        - script: |
            set -e
            echo "====================================="
            echo " Validate AWS Credentials"
            echo "====================================="

            mkdir -p ~/.aws

            cat > ~/.aws/credentials <<EOF
            [default]
            aws_access_key_id=$(AWS_ACCESS_KEY_ID)
            aws_secret_access_key=$(AWS_SECRET_ACCESS_KEY)
            EOF

            cat > ~/.aws/config <<EOF
            [default]
            region=$(AWS_DEFAULT_REGION)
            output=json
            EOF

            echo "AWS CLI Version:"
            aws --version

            aws sts get-caller-identity

            echo "âœ… AWS credentials valid"
          displayName: "Validate AWS Credentials"
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            set -e
            echo "====================================="
            echo " Install yq"
            echo "====================================="

            if ! command -v yq >/dev/null 2>&1; then
              echo "yq not found... installing..."
              mkdir -p $HOME/bin
              wget -qO $HOME/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
              chmod +x $HOME/bin/yq
              export PATH="$HOME/bin:$PATH"
              echo "##vso[task.prependpath]$HOME/bin"
            fi

            echo "yq version:"
            yq --version
          displayName: "Install yq"

        - script: |
            set -e
            echo "====================================="
            echo " Get Latest Image Tag from ECR"
            echo "====================================="

            AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
            ECR_REGISTRY="$AWS_ACCOUNT_ID.dkr.ecr.$(AWS_DEFAULT_REGION).amazonaws.com"

            LATEST_TAG=$(aws ecr describe-images \
              --repository-name $(APP_NAME) \
              --region $(AWS_DEFAULT_REGION) \
              --query 'sort_by(imageDetails,& imagePushedAt)[-1].imageTags[0]' \
              --output text)

            if [ -z "$LATEST_TAG" ] || [ "$LATEST_TAG" = "None" ]; then
              echo "âŒ Could not fetch latest image tag from ECR"
              exit 1
            fi

            echo "Latest image tag: $LATEST_TAG"
            echo "##vso[task.setvariable variable=LATEST_TAG]$LATEST_TAG"
            echo "##vso[task.setvariable variable=ECR_REGISTRY]$ECR_REGISTRY"
          displayName: "Get Latest Tag from ECR"
          env:
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            set -e
            echo "====================================="
            echo " Update GitOps values-nonprod.yaml"
            echo "====================================="

            VALUES_FILE="$(GITOPS_DIR)/nonprod/$(APP_NAME)/values-nonprod.yaml"

            if [ ! -f "$VALUES_FILE" ]; then
              echo "âŒ values file not found: $VALUES_FILE"
              exit 1
            fi

            echo "Updating image.repository and image.tag..."

            yq -i ".image.repository = \"$(ECR_REGISTRY)/$(APP_NAME)\"" $VALUES_FILE
            yq -i ".image.tag = \"$(LATEST_TAG)\"" $VALUES_FILE

            echo ""
            echo "Updated file content:"
            cat $VALUES_FILE
          displayName: "Update GitOps Values File"

        - script: |
            set -e
            echo "====================================="
            echo " Commit & Push GitOps Changes"
            echo "====================================="

            git config user.email "azure-devops@nti.com"
            git config user.name "Azure DevOps Pipeline"

            echo "Fetching all branches..."
            git fetch --all

            echo "Stashing local changes..."
            git stash --include-untracked || true

            echo "Switching to main branch..."
            git checkout main 2>/dev/null || git checkout -B main origin/main

            echo "Pull latest changes from main..."
            git pull origin main --rebase || true

            echo "Restoring stashed changes..."
            git stash pop || true

            git add gitops/nonprod/$(APP_NAME)/values-nonprod.yaml

            git commit -m "Update $(APP_NAME) image tag to $(LATEST_TAG)" || echo "No changes to commit"

            echo "Pushing changes to GitHub..."
            git push origin HEAD:main
          displayName: "Commit & Push GitOps"

# ================================
# ArgoCD Sync Stage
# ================================
- stage: ArgoCD_Sync
  displayName: "ðŸ”„ ArgoCD Sync"
  dependsOn: GitOps_Update
  condition: and(succeeded(), eq(variables['RUN_ARGOCD_SYNC'], 'true'))

  jobs:
    - job: SyncArgo
      displayName: "Sync ArgoCD Application"
      timeoutInMinutes: 15

      steps:
        - checkout: self
          clean: true

        - task: KubectlInstaller@0
          displayName: "Install kubectl"
          inputs:
            kubectlVersion: "latest"

        - script: |
            set -e
            echo "====================================="
            echo " Configure AWS Credentials"
            echo "====================================="

            mkdir -p ~/.aws

            cat > ~/.aws/credentials <<EOF
            [default]
            aws_access_key_id=$(AWS_ACCESS_KEY_ID)
            aws_secret_access_key=$(AWS_SECRET_ACCESS_KEY)
            EOF

            cat > ~/.aws/config <<EOF
            [default]
            region=$(AWS_DEFAULT_REGION)
            output=json
            EOF

            aws sts get-caller-identity
            echo "âœ… AWS credentials valid"
          displayName: "Configure AWS Credentials"
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            set -e
            echo "====================================="
            echo " Configure kubeconfig"
            echo "====================================="

            mkdir -p $HOME/.kube

            aws eks update-kubeconfig \
              --region "$(AWS_DEFAULT_REGION)" \
              --name "$(CLUSTER_NAME)" \
              --kubeconfig "$HOME/.kube/config"

            export KUBECONFIG="$HOME/.kube/config"

            echo "====================================="
            echo " Check ArgoCD App Status"
            echo "====================================="

            kubectl get applications -n argo || true
            kubectl get application $(APP_NAME) -n argo -o wide || true
          displayName: "Check ArgoCD Application"
          env:
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

# ================================
# Smoke Test Stage
# ================================
- stage: Smoke_Tests
  displayName: "ðŸ§ª Smoke Tests"
  dependsOn: ArgoCD_Sync
  condition: and(succeeded(), eq(variables['RUN_SMOKE_TESTS'], 'true'))

  jobs:
    - job: RunSmokeTests
      displayName: "Run Smoke Tests"
      timeoutInMinutes: 15

      steps:
        - checkout: self
          clean: true

        - task: KubectlInstaller@0
          displayName: "Install kubectl"
          inputs:
            kubectlVersion: "latest"

        - script: |
            set -e
            echo "====================================="
            echo " Configure AWS Credentials"
            echo "====================================="

            mkdir -p ~/.aws

            cat > ~/.aws/credentials <<EOF
            [default]
            aws_access_key_id=$(AWS_ACCESS_KEY_ID)
            aws_secret_access_key=$(AWS_SECRET_ACCESS_KEY)
            EOF

            cat > ~/.aws/config <<EOF
            [default]
            region=$(AWS_DEFAULT_REGION)
            output=json
            EOF

            aws sts get-caller-identity
            echo "âœ… AWS credentials valid"
          displayName: "Configure AWS Credentials"
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            set -e
            echo "====================================="
            echo " Configure kubeconfig"
            echo "====================================="

            mkdir -p $HOME/.kube

            aws eks update-kubeconfig \
              --region "$(AWS_DEFAULT_REGION)" \
              --name "$(CLUSTER_NAME)" \
              --kubeconfig "$HOME/.kube/config"

            export KUBECONFIG="$HOME/.kube/config"

            echo "====================================="
            echo " Smoke Tests for $(APP_NAME)"
            echo "====================================="

            kubectl rollout status deployment/$(APP_NAME) -n $(APP_NAMESPACE) --timeout=300s

            kubectl get pods -n $(APP_NAMESPACE)
            kubectl get svc -n $(APP_NAMESPACE)
            kubectl get ingress -n $(APP_NAMESPACE) || true

            echo " Smoke tests passed"
          displayName: "Run Smoke Tests"
          env:
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)
