# ============================================================================
# Azure DevOps Infrastructure Pipeline - Terraform IaC
# ============================================================================
# This pipeline manages AWS infrastructure using Terraform
# Author: DevOps Team
# Version: 2.0.0
# ============================================================================

trigger:
  branches:
    include:
      - main
  paths:
    include:
      - terraform/**
      - azure-infra-pipeline.yaml

pr:
  branches:
    include:
      - main
  paths:
    include:
      - terraform/**

pool:
  name: self-hosted-pool
  demands:
     - Agent.OS -equals Linux

# ================================
# Pipeline Variables
# ================================
variables:
  # Terraform Configuration
  TF_WORKING_DIR: "terraform"
  TF_VERSION: "1.7.0"
  
  # AWS Configuration
  AWS_DEFAULT_REGION: "us-east-1"
  
  # State Backend
  TF_STATE_BUCKET: "nti-final-tfstate-842303506852-us-east-1-2026"
  TF_LOCK_TABLE: "nti-final-tflock-842303506852-us-east-1-2026"
  
  # Environment
  ENVIRONMENT: "nonprod"
  TF_VAR_FILE: "nonprod.tfvars"
  
  # Feature Flags
  RUN_DESTROY: "false"
  AUTO_APPROVE: "true"
  ENABLE_COST_ESTIMATION: "true"

# ================================
# Stages
# ================================
stages:

# ================================
# Validate Stage
# ================================
- stage: Validate
  displayName: "‚úÖ Validate Infrastructure"
  jobs:
    - job: ValidateTerraform
      displayName: "Validate Terraform Code"
      timeoutInMinutes: 30
      
      steps:
        - checkout: self
          clean: true
          fetchDepth: 1

        - script: |
            echo "====================================="
            echo "  Pipeline Information"
            echo "====================================="
            echo "Build ID: $(Build.BuildId)"
            echo "Branch: $(Build.SourceBranchName)"
            echo "Environment: $(ENVIRONMENT)"
            echo "Terraform Directory: $(TF_WORKING_DIR)"
            echo "====================================="
          displayName: "Pipeline Information"

        - script: |
            set -e
            echo "====================================="
            echo "  Verify Tools"
            echo "====================================="
            
            aws --version
            terraform --version
            git --version
            
            echo "‚úÖ All tools verified"
          displayName: "Verify Tools"

        - script: |
            set -e
            echo "====================================="
            echo "  Validate AWS Credentials"
            echo "====================================="
            
            aws sts get-caller-identity
            echo "‚úÖ AWS credentials validated"
          displayName: "Validate AWS Credentials"
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            set -e
            cd $(TF_WORKING_DIR)
            
            echo "====================================="
            echo "  Terraform Format Check"
            echo "====================================="
            
            if terraform fmt -check -recursive -diff; then
              echo "‚úÖ Code is properly formatted"
            else
              echo "‚ùå Code formatting issues found"
              echo "Run 'terraform fmt -recursive' to fix"
              exit 1
            fi
          displayName: "Terraform Format Check"

        - script: |
            set -e
            cd $(TF_WORKING_DIR)
            
            echo "====================================="
            echo "  Setup Terraform Backend"
            echo "====================================="
            
            # Check/Create S3 bucket
            if aws s3api head-bucket --bucket $(TF_STATE_BUCKET) 2>/dev/null; then
              echo "‚úÖ S3 bucket exists: $(TF_STATE_BUCKET)"
            else
              echo "Creating S3 bucket..."
              aws s3api create-bucket \
                --bucket $(TF_STATE_BUCKET) \
                --region $(AWS_DEFAULT_REGION)
              
              # Enable versioning
              aws s3api put-bucket-versioning \
                --bucket $(TF_STATE_BUCKET) \
                --versioning-configuration Status=Enabled
              
              # Enable encryption
              aws s3api put-bucket-encryption \
                --bucket $(TF_STATE_BUCKET) \
                --server-side-encryption-configuration '{"Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}'
              
              # Block public access
              aws s3api put-public-access-block \
                --bucket $(TF_STATE_BUCKET) \
                --public-access-block-configuration "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"
              
              echo "‚úÖ S3 bucket created with versioning and encryption"
            fi
            
            # Check/Create DynamoDB table
            if aws dynamodb describe-table --table-name $(TF_LOCK_TABLE) --region $(AWS_DEFAULT_REGION) >/dev/null 2>&1; then
              echo "‚úÖ DynamoDB table exists: $(TF_LOCK_TABLE)"
            else
              echo "Creating DynamoDB table..."
              aws dynamodb create-table \
                --table-name $(TF_LOCK_TABLE) \
                --attribute-definitions AttributeName=LockID,AttributeType=S \
                --key-schema AttributeName=LockID,KeyType=HASH \
                --billing-mode PAY_PER_REQUEST \
                --region $(AWS_DEFAULT_REGION)
              
              aws dynamodb wait table-exists --table-name $(TF_LOCK_TABLE) --region $(AWS_DEFAULT_REGION)
              echo "‚úÖ DynamoDB table created"
            fi
          displayName: "Setup Backend Resources"
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            set -e
            cd $(TF_WORKING_DIR)
            
            echo "====================================="
            echo "  Terraform Init"
            echo "====================================="
            
            terraform init \
              -backend-config="bucket=$(TF_STATE_BUCKET)" \
              -backend-config="key=eks/terraform.tfstate" \
              -backend-config="region=$(AWS_DEFAULT_REGION)" \
              -backend-config="dynamodb_table=$(TF_LOCK_TABLE)" \
              -backend-config="encrypt=true" \
              -reconfigure
            
            echo "‚úÖ Terraform initialized"
          displayName: "Terraform Init"
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            set -e
            cd $(TF_WORKING_DIR)
            
            echo "====================================="
            echo "  Terraform Validate"
            echo "====================================="
            
            terraform validate
            echo "‚úÖ Terraform configuration is valid"
          displayName: "Terraform Validate"

        - script: |
            set -e
            cd $(TF_WORKING_DIR)
            
            echo "====================================="
            echo "  Security Scan (tfsec)"
            echo "====================================="
            
            # Install tfsec if not present
            if ! command -v tfsec &> /dev/null; then
              echo "Installing tfsec..."
              curl -s https://raw.githubusercontent.com/aquasecurity/tfsec/master/scripts/install_linux.sh | bash
            fi
            
            # Run tfsec (non-blocking)
            tfsec . --format lovely || true
            
            echo "‚úÖ Security scan completed"
          displayName: "Security Scan"
          continueOnError: true

# ================================
# Plan Stage
# ================================
- stage: Plan
  displayName: "üìã Terraform Plan"
  dependsOn: Validate
  condition: succeeded()
  
  jobs:
    - job: TerraformPlan
      displayName: "Generate Terraform Plan"
      timeoutInMinutes: 30
      
      steps:
        - checkout: self
          clean: true
          fetchDepth: 1

        - script: |
            set -e
            cd $(TF_WORKING_DIR)
            
            echo "====================================="
            echo "  Terraform Init"
            echo "====================================="
            
            terraform init \
              -backend-config="bucket=$(TF_STATE_BUCKET)" \
              -backend-config="key=eks/terraform.tfstate" \
              -backend-config="region=$(AWS_DEFAULT_REGION)" \
              -backend-config="dynamodb_table=$(TF_LOCK_TABLE)" \
              -backend-config="encrypt=true" \
              -reconfigure
          displayName: "Terraform Init"
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            set -e
            cd $(TF_WORKING_DIR)
            
            echo "====================================="
            echo "  Terraform Plan"
            echo "====================================="
            
            # Generate plan - capture exit code properly
            set +e
            terraform plan \
              -var-file=$(TF_VAR_FILE) \
              -out=tfplan \
              -detailed-exitcode
            PLAN_EXIT=$?
            set -e
            
            # Interpret exit code
            case $PLAN_EXIT in
              0)
                echo "‚úÖ No changes required"
                echo "##vso[task.setvariable variable=CHANGES_DETECTED;isOutput=true]false"
                ;;
              1)
                echo "‚ùå Plan failed"
                exit 1
                ;;
              2)
                echo "üìù Changes detected"
                echo "##vso[task.setvariable variable=CHANGES_DETECTED;isOutput=true]true"
                ;;
            esac
            
            # Show plan summary
            echo ""
            echo "====================================="
            echo "  Plan Summary"
            echo "====================================="
            terraform show -no-color tfplan | grep -E "^Plan:|^  #|will be" || echo "No infrastructure changes to display"
          displayName: "Terraform Plan"
          name: tfplan
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            if [ "$(ENABLE_COST_ESTIMATION)" = "true" ]; then
              echo "====================================="
              echo "  Cost Estimation (Infracost)"
              echo "====================================="
              
              # Install infracost if not present
              if ! command -v infracost &> /dev/null; then
                echo "Installing infracost..."
                curl -fsSL https://raw.githubusercontent.com/infracost/infracost/master/scripts/install.sh | sh
              fi
              
              # Generate cost estimation (requires INFRACOST_API_KEY)
              if [ -n "$INFRACOST_API_KEY" ]; then
                cd $(TF_WORKING_DIR)
                infracost breakdown --path . --terraform-var-file=$(TF_VAR_FILE) || true
              else
                echo "‚ö†Ô∏è INFRACOST_API_KEY not set, skipping cost estimation"
              fi
            fi
          displayName: "Cost Estimation"
          continueOnError: true
          env:
            INFRACOST_API_KEY: $(INFRACOST_API_KEY)

        - task: PublishBuildArtifacts@1
          displayName: "Publish Terraform Plan"
          inputs:
            PathtoPublish: "$(TF_WORKING_DIR)/tfplan"
            ArtifactName: "terraform-plan"
            publishLocation: "Container"

# ================================
# Apply Stage
# ================================
- stage: Apply
  displayName: "üöÄ Terraform Apply"
  dependsOn: Plan
  condition: |
    and(
      succeeded(),
      eq(variables['Build.SourceBranch'], 'refs/heads/main'),
      ne(variables['RUN_DESTROY'], 'true')
    )
  
  jobs:
    - job: ApprovalGate
      displayName: "Manual Approval"
      condition: ne(variables['AUTO_APPROVE'], 'true')
      pool: server
      timeoutInMinutes: 1440  # 24 hours
      
      steps:
        - task: ManualValidation@0
          displayName: "Approve Infrastructure Changes"
          inputs:
            notifyUsers: ""
            instructions: "Please review the Terraform plan and approve to proceed with infrastructure changes."
            onTimeout: "reject"

    - job: TerraformApply
      displayName: "Apply Infrastructure Changes"
      dependsOn: ApprovalGate
      condition: or(succeeded(), eq(variables['AUTO_APPROVE'], 'true'))
      timeoutInMinutes: 60
      
      steps:
        - checkout: self
          clean: true
          fetchDepth: 1

        - task: DownloadBuildArtifacts@0
          displayName: "Download Terraform Plan"
          inputs:
            buildType: "current"
            downloadType: "single"
            artifactName: "terraform-plan"
            downloadPath: "$(System.ArtifactsDirectory)"

        - script: |
            set -e
            cd $(TF_WORKING_DIR)
            
            echo "====================================="
            echo "  Terraform Init"
            echo "====================================="
            
            terraform init \
              -backend-config="bucket=$(TF_STATE_BUCKET)" \
              -backend-config="key=eks/terraform.tfstate" \
              -backend-config="region=$(AWS_DEFAULT_REGION)" \
              -backend-config="dynamodb_table=$(TF_LOCK_TABLE)" \
              -backend-config="encrypt=true" \
              -reconfigure
          displayName: "Terraform Init"
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            set -e
            cd $(TF_WORKING_DIR)
            
            echo "====================================="
            echo "  Terraform Apply"
            echo "====================================="
            
            # Copy plan file
            cp $(System.ArtifactsDirectory)/terraform-plan/tfplan ./tfplan 2>/dev/null || {
              echo "Plan file not found, running fresh apply..."
              terraform apply -var-file=$(TF_VAR_FILE) -auto-approve
              exit 0
            }
            
            # Apply the saved plan
            terraform apply -auto-approve tfplan
            
            echo ""
            echo "‚úÖ Infrastructure changes applied successfully"
          displayName: "Terraform Apply"
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            set -e
            cd $(TF_WORKING_DIR)
            
            echo "====================================="
            echo "  Terraform Outputs"
            echo "====================================="
            
            terraform output -json > $(Build.ArtifactStagingDirectory)/terraform-outputs.json
            terraform output
            
            echo ""
            echo "‚úÖ Outputs saved"
          displayName: "Terraform Outputs"
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - task: PublishBuildArtifacts@1
          displayName: "Publish Terraform Outputs"
          inputs:
            PathtoPublish: "$(Build.ArtifactStagingDirectory)/terraform-outputs.json"
            ArtifactName: "terraform-outputs"
            publishLocation: "Container"

        - script: |
            echo "====================================="
            echo "  Infrastructure Summary"
            echo "====================================="
            echo ""
            echo "Environment: $(ENVIRONMENT)"
            echo "Region: $(AWS_DEFAULT_REGION)"
            echo ""
            echo "Resources provisioned:"
            echo "  - VPC and Networking"
            echo "  - EKS Cluster"
            echo "  - IAM Roles and Policies"
            echo "  - EBS CSI Driver"
            echo "  - ECR Repository"
            echo ""
            echo "‚úÖ Infrastructure deployment completed successfully"
          displayName: "Infrastructure Summary"

# ================================
# Destroy Stage (Manual Trigger Only)
# ================================
- stage: Destroy
  displayName: "üí• Terraform Destroy"
  dependsOn: Validate
  condition: |
    and(
      succeeded(),
      eq(variables['RUN_DESTROY'], 'true')
    )
  
  jobs:
    - job: DestroyApproval
      displayName: "Destroy Approval"
      pool: server
      timeoutInMinutes: 60
      
      steps:
        - task: ManualValidation@0
          displayName: "‚ö†Ô∏è CONFIRM DESTRUCTION"
          inputs:
            notifyUsers: ""
            instructions: |
              ‚ö†Ô∏è WARNING: You are about to DESTROY all infrastructure in $(ENVIRONMENT).
              
              This action is IRREVERSIBLE and will delete:
              - VPC and all networking resources
              - EKS Cluster and all workloads
              - ECR repositories and images
              - All persistent data
              
              Are you absolutely sure you want to proceed?
            onTimeout: "reject"

    - job: TerraformDestroy
      displayName: "Destroy Infrastructure"
      dependsOn: DestroyApproval
      timeoutInMinutes: 60
      
      steps:
        - checkout: self
          clean: true
          fetchDepth: 1

        - script: |
            set -e
            cd $(TF_WORKING_DIR)
            
            terraform init \
              -backend-config="bucket=$(TF_STATE_BUCKET)" \
              -backend-config="key=eks/terraform.tfstate" \
              -backend-config="region=$(AWS_DEFAULT_REGION)" \
              -backend-config="dynamodb_table=$(TF_LOCK_TABLE)" \
              -backend-config="encrypt=true" \
              -reconfigure
          displayName: "Terraform Init"
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            set -e
            cd $(TF_WORKING_DIR)
            
            echo "====================================="
            echo "  ‚ö†Ô∏è DESTROYING INFRASTRUCTURE"
            echo "====================================="
            
            terraform destroy -var-file=$(TF_VAR_FILE) -auto-approve
            
            echo ""
            echo "‚úÖ Infrastructure destroyed"
          displayName: "Terraform Destroy"
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)
