trigger:
  branches:
    include:
      - main

pool:
  name: SelfHostedPool
  demands:
    - agent.os -equals Linux

variables:
  TF_WORKING_DIR: "terraform"
  HELM_WORKING_DIR: "helm"

  AWS_DEFAULT_REGION: "us-east-1"

  # Backend resources
  TF_STATE_BUCKET: "nti-finalproject-terraform-state"
  TF_LOCK_TABLE: "nti-finalproject-terraform-lock"

  # Control flags
  DEPLOY_HELM: "true"
  RUN_DESTROY: "false"

stages:

# ================================
# Terraform Apply Stage
# ================================
- stage: Terraform_Apply
  displayName: "Terraform Apply Stage"
  jobs:
    - job: TerraformApply
      displayName: "Terraform Apply"
      timeoutInMinutes: 60
      cancelTimeoutInMinutes: 5

      workspace:
        clean: all

      steps:
        - checkout: self

        - script: |
            echo "====================================="
            echo " Agent Info"
            echo "====================================="
            echo "Agent Name: $(Agent.Name)"
            echo "Agent OS: $(Agent.OS)"
            echo "Build ID: $(Build.BuildId)"
            echo "====================================="
            df -h
          displayName: "Agent Health Check"

        - script: |
            echo "====================================="
            echo " Verifying Required Tools"
            echo "====================================="
            aws --version
            terraform --version
            kubectl version --client || echo "kubectl not installed"
            helm version || echo "helm not installed"
          displayName: "Verify Tools"

        - script: |
            echo "====================================="
            echo " Validating AWS Credentials"
            echo "====================================="
            aws sts get-caller-identity
          displayName: "Validate AWS Credentials"
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            set -e
            echo "====================================="
            echo " Creating Backend Resources if Missing"
            echo "====================================="

            echo "Checking S3 bucket: $(TF_STATE_BUCKET)"
            if aws s3api head-bucket --bucket $(TF_STATE_BUCKET) 2>/dev/null; then
              echo "S3 bucket exists"
            else
              echo "Creating S3 bucket..."
              aws s3api create-bucket --bucket $(TF_STATE_BUCKET) --region $(AWS_DEFAULT_REGION)
              aws s3api put-bucket-versioning --bucket $(TF_STATE_BUCKET) --versioning-configuration Status=Enabled
              echo "S3 bucket created + versioning enabled"
            fi

            echo "Checking DynamoDB table: $(TF_LOCK_TABLE)"
            if aws dynamodb describe-table --table-name $(TF_LOCK_TABLE) --region $(AWS_DEFAULT_REGION) >/dev/null 2>&1; then
              echo "DynamoDB table exists"
            else
              echo "Creating DynamoDB table..."
              aws dynamodb create-table \
                --table-name $(TF_LOCK_TABLE) \
                --attribute-definitions AttributeName=LockID,AttributeType=S \
                --key-schema AttributeName=LockID,KeyType=HASH \
                --billing-mode PAY_PER_REQUEST \
                --region $(AWS_DEFAULT_REGION)

              echo "Waiting for table to become active..."
              aws dynamodb wait table-exists --table-name $(TF_LOCK_TABLE) --region $(AWS_DEFAULT_REGION)
              echo "DynamoDB table created"
            fi

          displayName: "Setup Backend Resources"
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            set -e
            cd $(TF_WORKING_DIR)

            echo "====================================="
            echo " Terraform Init"
            echo "====================================="
            terraform init -reconfigure
          displayName: "Terraform Init"
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            set -e
            cd $(TF_WORKING_DIR)

            echo "====================================="
            echo " Terraform Validate"
            echo "====================================="
            terraform validate
          displayName: "Terraform Validate"
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            set -e
            cd $(TF_WORKING_DIR)

            echo "====================================="
            echo " Terraform Plan"
            echo "====================================="
            terraform plan -var-file=nonprod.tfvars -out=tfplan
          displayName: "Terraform Plan"
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            set -e
            cd $(TF_WORKING_DIR)

            echo "====================================="
            echo " Terraform Apply"
            echo "====================================="
            terraform apply -auto-approve tfplan
          displayName: "Terraform Apply"
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            cd $(TF_WORKING_DIR)

            echo "====================================="
            echo " Terraform Outputs"
            echo "====================================="
            terraform output
          displayName: "Terraform Outputs"
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)


# ================================
# Helm Deploy Stage
# ================================
- stage: Helm_Deploy
  displayName: "Helm Deployment Stage"
  dependsOn: Terraform_Apply
  condition: and(succeeded(), eq(variables['DEPLOY_HELM'], 'true'))

  jobs:
    - job: HelmDeploy
      displayName: "Deploy Applications with Helm"
      timeoutInMinutes: 40
      cancelTimeoutInMinutes: 5

      workspace:
        clean: all

      steps:
        - checkout: self

        - task: HelmInstaller@1
          displayName: "Install Helm"
          inputs:
            helmVersionToInstall: "latest"

        - task: KubectlInstaller@0
          displayName: "Install kubectl"
          inputs:
            kubectlVersion: "latest"

        - script: |
            set -e
            echo "====================================="
            echo " Configure kubectl for EKS"
            echo "====================================="

            cd $(TF_WORKING_DIR)
            terraform init -reconfigure

            echo "Reading EKS cluster name from Terraform outputs..."
            CLUSTER_NAME=$(terraform output -raw eks_cluster_name)

            echo "Cluster Name: $CLUSTER_NAME"
            echo "Region: $(AWS_DEFAULT_REGION)"

            echo "Verifying cluster exists..."
            aws eks describe-cluster --name "$CLUSTER_NAME" --region "$(AWS_DEFAULT_REGION)" >/dev/null

            echo "Creating kubeconfig directory..."
            mkdir -p $(Agent.TempDirectory)/.kube
            export KUBECONFIG=$(Agent.TempDirectory)/.kube/config

            echo "Updating kubeconfig..."
            aws eks update-kubeconfig \
              --region "$(AWS_DEFAULT_REGION)" \
              --name "$CLUSTER_NAME" \
              --kubeconfig "$KUBECONFIG"

            echo "Setting pipeline variable KUBECONFIG..."
            echo "##vso[task.setvariable variable=KUBECONFIG]$KUBECONFIG"

            echo "Testing kubectl..."
            kubectl get nodes
            kubectl get ns
          displayName: "Configure kubectl"
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)

        - script: |
            set -e
            echo "====================================="
            echo " Deploy Helm Chart"
            echo "====================================="

            export KUBECONFIG=$(KUBECONFIG)

            helm upgrade --install nti-app $(HELM_WORKING_DIR)/nti-app \
              --namespace nti-app \
              --create-namespace \
              --values $(HELM_WORKING_DIR)/nti-app/values-nonprod.yaml \
              --wait \
              --timeout 10m

            echo "Helm Deployment Completed!"
          displayName: "Helm Upgrade/Install"
          env:
            KUBECONFIG: $(KUBECONFIG)

        - script: |
            echo "====================================="
            echo " Verify Deployment"
            echo "====================================="

            export KUBECONFIG=$(KUBECONFIG)

            kubectl get pods -n nti-app
            kubectl get svc -n nti-app
            kubectl get ingress -n nti-app || echo "No ingress found"
          displayName: "Verify Kubernetes Resources"
          env:
            KUBECONFIG: $(KUBECONFIG)


# ================================
# Terraform Destroy Stage (Manual)
# ================================
- stage: Terraform_Destroy
  displayName: "Terraform Destroy Stage"
  dependsOn: Terraform_Apply
  condition: eq(variables['RUN_DESTROY'], 'true')

  jobs:
    - job: TerraformDestroy
      displayName: "Terraform Destroy"
      timeoutInMinutes: 40
      cancelTimeoutInMinutes: 5

      steps:
        - checkout: self

        - script: |
            set -e
            cd $(TF_WORKING_DIR)

            terraform init -reconfigure
            terraform destroy -var-file=nonprod.tfvars -auto-approve
          displayName: "Terraform Destroy"
          env:
            AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
            AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
            AWS_DEFAULT_REGION: $(AWS_DEFAULT_REGION)
